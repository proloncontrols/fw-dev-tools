<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srecord: srecord::memory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srecord<span id="projectnumber">&#160;1.65.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsrecord_1_1memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsrecord_1_1memory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srecord::memory Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classsrecord_1_1memory.html" title="The srecord::memory class is used to simulate memory contents.">srecord::memory</a> class is used to simulate memory contents.  
 <a href="classsrecord_1_1memory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8h_source.html">memory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a879ef28995e8c9481036db9ed4a0b882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a879ef28995e8c9481036db9ed4a0b882">memory</a> ()</td></tr>
<tr class="memdesc:a879ef28995e8c9481036db9ed4a0b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="classsrecord_1_1memory.html#a879ef28995e8c9481036db9ed4a0b882">More...</a><br /></td></tr>
<tr class="separator:a879ef28995e8c9481036db9ed4a0b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47de9f19393a099a3aa4d023bbf347c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a47de9f19393a099a3aa4d023bbf347c5">memory</a> (const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;)</td></tr>
<tr class="memdesc:a47de9f19393a099a3aa4d023bbf347c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="classsrecord_1_1memory.html#a47de9f19393a099a3aa4d023bbf347c5">More...</a><br /></td></tr>
<tr class="separator:a47de9f19393a099a3aa4d023bbf347c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02982f5ce2af5d124dee70c55291b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#ac02982f5ce2af5d124dee70c55291b82">operator=</a> (const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;)</td></tr>
<tr class="memdesc:ac02982f5ce2af5d124dee70c55291b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator.  <a href="classsrecord_1_1memory.html#ac02982f5ce2af5d124dee70c55291b82">More...</a><br /></td></tr>
<tr class="separator:ac02982f5ce2af5d124dee70c55291b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825b56cea2c8ed2b2216e9261778a98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a7825b56cea2c8ed2b2216e9261778a98">~memory</a> ()</td></tr>
<tr class="memdesc:a7825b56cea2c8ed2b2216e9261778a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="classsrecord_1_1memory.html#a7825b56cea2c8ed2b2216e9261778a98">More...</a><br /></td></tr>
<tr class="separator:a7825b56cea2c8ed2b2216e9261778a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c493d00308b08832b47aa5750822be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a9c493d00308b08832b47aa5750822be1">set</a> (unsigned long address, int value)</td></tr>
<tr class="memdesc:a9c493d00308b08832b47aa5750822be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set method is used to set the byte at the given &lsquo;address&rsquo; to the given &lsquo;value&rsquo;.  <a href="classsrecord_1_1memory.html#a9c493d00308b08832b47aa5750822be1">More...</a><br /></td></tr>
<tr class="separator:a9c493d00308b08832b47aa5750822be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bffe341c6c44a271c081fb798189ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a23bffe341c6c44a271c081fb798189ef">get</a> (unsigned long address) const</td></tr>
<tr class="memdesc:a23bffe341c6c44a271c081fb798189ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get method is used to fetch the value of the byte at the given 'address'.  <a href="classsrecord_1_1memory.html#a23bffe341c6c44a271c081fb798189ef">More...</a><br /></td></tr>
<tr class="separator:a23bffe341c6c44a271c081fb798189ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f073a2f82d2c2c39406c83b5fdf07b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#ae0f073a2f82d2c2c39406c83b5fdf07b">set_p</a> (unsigned long address) const</td></tr>
<tr class="memdesc:ae0f073a2f82d2c2c39406c83b5fdf07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set_p method is used to determine whether the byte at the given address has been <a class="el" href="classsrecord_1_1memory.html#a9c493d00308b08832b47aa5750822be1" title="The set method is used to set the byte at the given ‘address’ to the given ‘value’.">set()</a> yet.  <a href="classsrecord_1_1memory.html#ae0f073a2f82d2c2c39406c83b5fdf07b">More...</a><br /></td></tr>
<tr class="separator:ae0f073a2f82d2c2c39406c83b5fdf07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779cea82cd54ff55f3c52683cb0faa8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a779cea82cd54ff55f3c52683cb0faa8b">walk</a> (<a class="el" href="classsrecord_1_1memory__walker.html#ad2e4e884c29d16345e31b22759f56b2f">memory_walker::pointer</a>) const</td></tr>
<tr class="memdesc:a779cea82cd54ff55f3c52683cb0faa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The walk method is used to apply a <a class="el" href="classsrecord_1_1memory__walker.html" title="The srecord::memory_walker class is used to represent an abstract handler for the action to perform w...">memory_walker</a> derived class to every byte of memory.  <a href="classsrecord_1_1memory.html#a779cea82cd54ff55f3c52683cb0faa8b">More...</a><br /></td></tr>
<tr class="separator:a779cea82cd54ff55f3c52683cb0faa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3e2b40ca119f6f68b12877dac485a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6">reader</a> (const <a class="el" href="classsrecord_1_1input.html#a9aa795f67238fa82738cc79d77d44904">input::pointer</a> &amp;<a class="el" href="classsrecord_1_1input.html">input</a>, <a class="el" href="namespacesrecord.html#a55c4bceed0e71c3568cdafa27e34b77c">defcon_t</a> redundant_bytes, <a class="el" href="namespacesrecord.html#a55c4bceed0e71c3568cdafa27e34b77c">defcon_t</a> contradictory_bytes)</td></tr>
<tr class="memdesc:adf3e2b40ca119f6f68b12877dac485a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reader method is used to read the given &lsquo;input&rsquo; source into memory.  <a href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6">More...</a><br /></td></tr>
<tr class="separator:adf3e2b40ca119f6f68b12877dac485a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbc6a26d13b6f83ab8d2d1d446fa849"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#acbbc6a26d13b6f83ab8d2d1d446fa849">find_next_data</a> (unsigned long &amp;address, void *data, size_t &amp;nbytes) const</td></tr>
<tr class="memdesc:acbbc6a26d13b6f83ab8d2d1d446fa849"><td class="mdescLeft">&#160;</td><td class="mdescRight">The find_next_data method may be used to locate data at or following the &lsquo;address&rsquo; given.  <a href="classsrecord_1_1memory.html#acbbc6a26d13b6f83ab8d2d1d446fa849">More...</a><br /></td></tr>
<tr class="separator:acbbc6a26d13b6f83ab8d2d1d446fa849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb658b9ce30fd68890191afccfbb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrecord_1_1record.html">record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#abaeb658b9ce30fd68890191afccfbb7f">get_header</a> (void) const</td></tr>
<tr class="memdesc:abaeb658b9ce30fd68890191afccfbb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_header method is used to determine the value of the header record set by either the <a class="el" href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6" title="The reader method is used to read the given ‘input’ source into memory.">reader()</a> or <a class="el" href="classsrecord_1_1memory.html#a4fd5f6cb15cd9f70438587c5dc445ce4" title="The set_header method may be used to set the header command.">set_header()</a> methods.  <a href="classsrecord_1_1memory.html#abaeb658b9ce30fd68890191afccfbb7f">More...</a><br /></td></tr>
<tr class="separator:abaeb658b9ce30fd68890191afccfbb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd5f6cb15cd9f70438587c5dc445ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a4fd5f6cb15cd9f70438587c5dc445ce4">set_header</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a4fd5f6cb15cd9f70438587c5dc445ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set_header method may be used to set the header command.  <a href="classsrecord_1_1memory.html#a4fd5f6cb15cd9f70438587c5dc445ce4">More...</a><br /></td></tr>
<tr class="separator:a4fd5f6cb15cd9f70438587c5dc445ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cb00e80d75a7004caf53d94b963f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrecord_1_1record.html">record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a47cb00e80d75a7004caf53d94b963f55">get_execution_start_address</a> (void) const</td></tr>
<tr class="memdesc:a47cb00e80d75a7004caf53d94b963f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_execution_start_address method is used to determine the value of the execution start address record set by either the <a class="el" href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6" title="The reader method is used to read the given ‘input’ source into memory.">reader()</a> or <a class="el" href="classsrecord_1_1memory.html#a0a613fa0989352017f545c0c41e6dc66" title="The set_execution_start_address method may be used to set the execution start address record.">set_execution_start_address()</a> methods.  <a href="classsrecord_1_1memory.html#a47cb00e80d75a7004caf53d94b963f55">More...</a><br /></td></tr>
<tr class="separator:a47cb00e80d75a7004caf53d94b963f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a613fa0989352017f545c0c41e6dc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a0a613fa0989352017f545c0c41e6dc66">set_execution_start_address</a> (unsigned long value)</td></tr>
<tr class="memdesc:a0a613fa0989352017f545c0c41e6dc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set_execution_start_address method may be used to set the execution start address record.  <a href="classsrecord_1_1memory.html#a0a613fa0989352017f545c0c41e6dc66">More...</a><br /></td></tr>
<tr class="separator:a0a613fa0989352017f545c0c41e6dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adef32ecc8621952cb5c9ba23af182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#ae3adef32ecc8621952cb5c9ba23af182">has_holes</a> (void) const</td></tr>
<tr class="memdesc:ae3adef32ecc8621952cb5c9ba23af182"><td class="mdescLeft">&#160;</td><td class="mdescRight">The has_holes method may be used to determine whether or not the memory data has "holes" in it.  <a href="classsrecord_1_1memory.html#ae3adef32ecc8621952cb5c9ba23af182">More...</a><br /></td></tr>
<tr class="separator:ae3adef32ecc8621952cb5c9ba23af182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ada3be9410298a3776ee400d60e26b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#af2ada3be9410298a3776ee400d60e26b">get_lower_bound</a> () const</td></tr>
<tr class="memdesc:af2ada3be9410298a3776ee400d60e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_lower_bound method is used to obtain the lower bound (lowest address) of the memory image.  <a href="classsrecord_1_1memory.html#af2ada3be9410298a3776ee400d60e26b">More...</a><br /></td></tr>
<tr class="separator:af2ada3be9410298a3776ee400d60e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8b20c37368c90efc1a3454f1adec75"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a1a8b20c37368c90efc1a3454f1adec75">get_upper_bound</a> () const</td></tr>
<tr class="memdesc:a1a8b20c37368c90efc1a3454f1adec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_upper_bound method is used to obtain the upper bound (maximum address plus one) of the memory image.  <a href="classsrecord_1_1memory.html#a1a8b20c37368c90efc1a3454f1adec75">More...</a><br /></td></tr>
<tr class="separator:a1a8b20c37368c90efc1a3454f1adec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42a5be2061960a4ccb34831697b915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a5a42a5be2061960a4ccb34831697b915">is_well_aligned</a> (unsigned multiple) const</td></tr>
<tr class="memdesc:a5a42a5be2061960a4ccb34831697b915"><td class="mdescLeft">&#160;</td><td class="mdescRight">The is_well_aligned method is used to test whether or not all of the data in the memory buffer is well aligned, on the given byte boundary.  <a href="classsrecord_1_1memory.html#a5a42a5be2061960a4ccb34831697b915">More...</a><br /></td></tr>
<tr class="separator:a5a42a5be2061960a4ccb34831697b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bc0a5435063bed47206bbcd0d8114a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a23bc0a5435063bed47206bbcd0d8114a">empty</a> (void) const</td></tr>
<tr class="memdesc:a23bc0a5435063bed47206bbcd0d8114a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty method is used to determine whether or not this memory image has no data in it.  <a href="classsrecord_1_1memory.html#a23bc0a5435063bed47206bbcd0d8114a">More...</a><br /></td></tr>
<tr class="separator:a23bc0a5435063bed47206bbcd0d8114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8bcb10389f5b0d8a5f6af7e6c3e80d5f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a8bcb10389f5b0d8a5f6af7e6c3e80d5f">equal</a> (const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;, const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;)</td></tr>
<tr class="memdesc:a8bcb10389f5b0d8a5f6af7e6c3e80d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The equal method may be used to determine if two memory instances are equal.  <a href="classsrecord_1_1memory.html#a8bcb10389f5b0d8a5f6af7e6c3e80d5f">More...</a><br /></td></tr>
<tr class="separator:a8bcb10389f5b0d8a5f6af7e6c3e80d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17acb86ad86932bce7dee06b5cb63044"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrecord_1_1memory.html#a17acb86ad86932bce7dee06b5cb63044">compare</a> (const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;, const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;)</td></tr>
<tr class="memdesc:a17acb86ad86932bce7dee06b5cb63044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compare method may be used to determine if two memory instances are equal.  <a href="classsrecord_1_1memory.html#a17acb86ad86932bce7dee06b5cb63044">More...</a><br /></td></tr>
<tr class="separator:a17acb86ad86932bce7dee06b5cb63044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classsrecord_1_1memory.html" title="The srecord::memory class is used to simulate memory contents.">srecord::memory</a> class is used to simulate memory contents. </p>
<p >This allows staging of reord adta, and also validation of contents. </p>

<p class="definition">Definition at line <a class="el" href="memory_8h_source.html#l00039">39</a> of file <a class="el" href="memory_8h_source.html">memory.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a879ef28995e8c9481036db9ed4a0b882" name="a879ef28995e8c9481036db9ed4a0b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879ef28995e8c9481036db9ed4a0b882">&#9670;&#160;</a></span>memory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">srecord::memory::memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor. </p>

</div>
</div>
<a id="a47de9f19393a099a3aa4d023bbf347c5" name="a47de9f19393a099a3aa4d023bbf347c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47de9f19393a099a3aa4d023bbf347c5">&#9670;&#160;</a></span>memory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">srecord::memory::memory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor. </p>

</div>
</div>
<a id="a7825b56cea2c8ed2b2216e9261778a98" name="a7825b56cea2c8ed2b2216e9261778a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7825b56cea2c8ed2b2216e9261778a98">&#9670;&#160;</a></span>~memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">srecord::memory::~memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac02982f5ce2af5d124dee70c55291b82" name="ac02982f5ce2af5d124dee70c55291b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02982f5ce2af5d124dee70c55291b82">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrecord_1_1memory.html">memory</a> &amp; srecord::memory::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The assignment operator. </p>

</div>
</div>
<a id="a9c493d00308b08832b47aa5750822be1" name="a9c493d00308b08832b47aa5750822be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c493d00308b08832b47aa5750822be1">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srecord::memory::set </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set method is used to set the byte at the given &lsquo;address&rsquo; to the given &lsquo;value&rsquo;. </p>
<p >Uses the find() method to locate the chunk, and then calls the <a class="el" href="classsrecord_1_1memory__chunk.html#a8484f994919a4a8b211ff5a6031c2185" title="The set method is used to set the byte at the given offset within the chunk.">memory_chunk::set</a> method, to set the byte within the chunk. </p>

</div>
</div>
<a id="a23bffe341c6c44a271c081fb798189ef" name="a23bffe341c6c44a271c081fb798189ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bffe341c6c44a271c081fb798189ef">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int srecord::memory::get </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The get method is used to fetch the value of the byte at the given 'address'. </p>
<p >If you fo a get on an address which has not been <a class="el" href="classsrecord_1_1memory.html#a9c493d00308b08832b47aa5750822be1" title="The set method is used to set the byte at the given ‘address’ to the given ‘value’.">set()</a> yet, the results are undefined.</p>
<p >Uses the find() method to locate the chunk, and then calls the <a class="el" href="classsrecord_1_1memory__chunk.html#ade71b1e298793e6dd94bacf1524b5b52" title="The get method is used to get the value at the given offset within the chunk.">memory_chunk::get</a> method, to get the byte within the chunk. </p>

</div>
</div>
<a id="ae0f073a2f82d2c2c39406c83b5fdf07b" name="ae0f073a2f82d2c2c39406c83b5fdf07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f073a2f82d2c2c39406c83b5fdf07b">&#9670;&#160;</a></span>set_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srecord::memory::set_p </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set_p method is used to determine whether the byte at the given address has been <a class="el" href="classsrecord_1_1memory.html#a9c493d00308b08832b47aa5750822be1" title="The set method is used to set the byte at the given ‘address’ to the given ‘value’.">set()</a> yet. </p>
<p >Returns true if already set, false if never been set.</p>
<p >Uses the find() method to locate the chunk, and then calls the <a class="el" href="classsrecord_1_1memory__chunk.html#a115da5d0da6a609de91ecdc1526f193c" title="The get_p method is used to determine whether the byte at the given offset within the chunk contains ...">memory_chunk::set_p</a> method, to get the status of the byte within the chunk. </p>

</div>
</div>
<a id="a779cea82cd54ff55f3c52683cb0faa8b" name="a779cea82cd54ff55f3c52683cb0faa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779cea82cd54ff55f3c52683cb0faa8b">&#9670;&#160;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srecord::memory::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsrecord_1_1memory__walker.html#ad2e4e884c29d16345e31b22759f56b2f">memory_walker::pointer</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The walk method is used to apply a <a class="el" href="classsrecord_1_1memory__walker.html" title="The srecord::memory_walker class is used to represent an abstract handler for the action to perform w...">memory_walker</a> derived class to every byte of memory. </p>

</div>
</div>
<a id="adf3e2b40ca119f6f68b12877dac485a6" name="adf3e2b40ca119f6f68b12877dac485a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3e2b40ca119f6f68b12877dac485a6">&#9670;&#160;</a></span>reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srecord::memory::reader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1input.html#a9aa795f67238fa82738cc79d77d44904">input::pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesrecord.html#a55c4bceed0e71c3568cdafa27e34b77c">defcon_t</a>&#160;</td>
          <td class="paramname"><em>redundant_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesrecord.html#a55c4bceed0e71c3568cdafa27e34b77c">defcon_t</a>&#160;</td>
          <td class="paramname"><em>contradictory_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reader method is used to read the given &lsquo;input&rsquo; source into memory. </p>
<p >This method may be called multiple times, for multiple input files.</p>
<p >If the input format supports headers, and the file has a header, the first header will be remembered, if <a class="el" href="classsrecord_1_1memory.html#a4fd5f6cb15cd9f70438587c5dc445ce4" title="The set_header method may be used to set the header command.">set_header()</a> was not called previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The source of the byte stream </td></tr>
    <tr><td class="paramname">redundant_bytes</td><td>ignore: do nothing warning: issue a warning and continue (default) error: issuse a atal error message, and exit failure. </td></tr>
    <tr><td class="paramname">contradictory_bytes</td><td>If the value at any address is set more than once, Thid argument controls what happeens. ignore: do nothing warning: issue a warning and continue (default) error: issuse a atal error message, and exit failure (default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bcb10389f5b0d8a5f6af7e6c3e80d5f" name="a8bcb10389f5b0d8a5f6af7e6c3e80d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb10389f5b0d8a5f6af7e6c3e80d5f">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool srecord::memory::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The equal method may be used to determine if two memory instances are equal. </p>

</div>
</div>
<a id="a17acb86ad86932bce7dee06b5cb63044" name="a17acb86ad86932bce7dee06b5cb63044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17acb86ad86932bce7dee06b5cb63044">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool srecord::memory::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsrecord_1_1memory.html">memory</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The compare method may be used to determine if two memory instances are equal. </p>
<p >Verbose messages concerning the exact differences are printed if they are not equal. </p>

</div>
</div>
<a id="acbbc6a26d13b6f83ab8d2d1d446fa849" name="acbbc6a26d13b6f83ab8d2d1d446fa849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbc6a26d13b6f83ab8d2d1d446fa849">&#9670;&#160;</a></span>find_next_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srecord::memory::find_next_data </td>
          <td>(</td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The find_next_data method may be used to locate data at or following the &lsquo;address&rsquo; given. </p>
<p >Returns false if there is no data meeting this criteria.</p>
<p >If there is data, the &lsquo;address&rsquo; will be set to the start address of the data block. At most &lsquo;nbytes&rsquo; of data will be transfetrred into the &lsquo;data&rsquo; array. Then &lsquo;nbytes&rsquo; wil be set to the number of bytes transferred. Returns true.</p>
<p >Calls the find_next_chunk() method. </p>

</div>
</div>
<a id="abaeb658b9ce30fd68890191afccfbb7f" name="abaeb658b9ce30fd68890191afccfbb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeb658b9ce30fd68890191afccfbb7f">&#9670;&#160;</a></span>get_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrecord_1_1record.html">record</a> * srecord::memory::get_header </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The get_header method is used to determine the value of the header record set by either the <a class="el" href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6" title="The reader method is used to read the given ‘input’ source into memory.">reader()</a> or <a class="el" href="classsrecord_1_1memory.html#a4fd5f6cb15cd9f70438587c5dc445ce4" title="The set_header method may be used to set the header command.">set_header()</a> methods. </p>
<p >If neither has set a header, a NULL is returned. </p>

</div>
</div>
<a id="a4fd5f6cb15cd9f70438587c5dc445ce4" name="a4fd5f6cb15cd9f70438587c5dc445ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd5f6cb15cd9f70438587c5dc445ce4">&#9670;&#160;</a></span>set_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srecord::memory::set_header </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set_header method may be used to set the header command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The &lsquo;value&rsquo; string, to set the header. The user may use URL encoding for of the more interesting non-printable byte values (eg. "%3F"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47cb00e80d75a7004caf53d94b963f55" name="a47cb00e80d75a7004caf53d94b963f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cb00e80d75a7004caf53d94b963f55">&#9670;&#160;</a></span>get_execution_start_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrecord_1_1record.html">record</a> * srecord::memory::get_execution_start_address </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The get_execution_start_address method is used to determine the value of the execution start address record set by either the <a class="el" href="classsrecord_1_1memory.html#adf3e2b40ca119f6f68b12877dac485a6" title="The reader method is used to read the given ‘input’ source into memory.">reader()</a> or <a class="el" href="classsrecord_1_1memory.html#a0a613fa0989352017f545c0c41e6dc66" title="The set_execution_start_address method may be used to set the execution start address record.">set_execution_start_address()</a> methods. </p>
<p >If neither has set an execution start address, NULL is returned. </p>

</div>
</div>
<a id="a0a613fa0989352017f545c0c41e6dc66" name="a0a613fa0989352017f545c0c41e6dc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a613fa0989352017f545c0c41e6dc66">&#9670;&#160;</a></span>set_execution_start_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srecord::memory::set_execution_start_address </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set_execution_start_address method may be used to set the execution start address record. </p>

</div>
</div>
<a id="ae3adef32ecc8621952cb5c9ba23af182" name="ae3adef32ecc8621952cb5c9ba23af182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3adef32ecc8621952cb5c9ba23af182">&#9670;&#160;</a></span>has_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srecord::memory::has_holes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The has_holes method may be used to determine whether or not the memory data has "holes" in it. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the memory data is not continuous (has at least one hole), false if the memory data is continuous (has no holes). </dd></dl>

</div>
</div>
<a id="af2ada3be9410298a3776ee400d60e26b" name="af2ada3be9410298a3776ee400d60e26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ada3be9410298a3776ee400d60e26b">&#9670;&#160;</a></span>get_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long srecord::memory::get_lower_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The get_lower_bound method is used to obtain the lower bound (lowest address) of the memory image. </p>

</div>
</div>
<a id="a1a8b20c37368c90efc1a3454f1adec75" name="a1a8b20c37368c90efc1a3454f1adec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8b20c37368c90efc1a3454f1adec75">&#9670;&#160;</a></span>get_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long srecord::memory::get_upper_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The get_upper_bound method is used to obtain the upper bound (maximum address plus one) of the memory image. </p>

</div>
</div>
<a id="a5a42a5be2061960a4ccb34831697b915" name="a5a42a5be2061960a4ccb34831697b915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a42a5be2061960a4ccb34831697b915">&#9670;&#160;</a></span>is_well_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srecord::memory::is_well_aligned </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The is_well_aligned method is used to test whether or not all of the data in the memory buffer is well aligned, on the given byte boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiple</td><td>The desired byte alignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This isn't about holes, it's about the beginnings and endings of each consecitice run of bytes. </dd></dl>

</div>
</div>
<a id="a23bc0a5435063bed47206bbcd0d8114a" name="a23bc0a5435063bed47206bbcd0d8114a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bc0a5435063bed47206bbcd0d8114a">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srecord::memory::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The empty method is used to determine whether or not this memory image has no data in it. </p>

<p class="definition">Definition at line <a class="el" href="memory_8h_source.html#l00228">228</a> of file <a class="el" href="memory_8h_source.html">memory.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="memory_8h_source.html">memory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesrecord.html">srecord</a></li><li class="navelem"><a class="el" href="classsrecord_1_1memory.html">memory</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
